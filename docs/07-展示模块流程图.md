# 展示模块详细流程

```mermaid
flowchart TD
    Start([用户访问展示页面]) --> A[加载展示配置]
    A --> B{展示模式}
    
    B -->|时间轴模式| C[时间轴展示流程]
    B -->|事件中心模式| D[事件展示流程]
    B -->|混合模式| E[混合展示流程]
    
    C --> C1[查询时间范围数据]
    C1 --> C2[从Neo4j查询节点]
    C2 --> C3[按时间排序]
    C3 --> C4[构建时间轴结构]
    C4 --> C5[计算节点关系]
    C5 --> C6[生成可视化数据]
    C6 --> C7[返回时间轴数据]
    
    D --> D1[查询用户事件列表]
    D1 --> D2[获取事件详情]
    D2 --> D3[查询事件关联关系]
    D3 --> D4[计算事件重要性]
    D4 --> D5[构建事件树状结构]
    D5 --> D6[获取事件相关速记]
    D6 --> D7[返回事件中心数据]
    
    E --> E1[并行查询时间和事件]
    E1 --> E2[合并查询结果]
    E2 --> E3[计算展示优先级]
    E3 --> E4[生成混合布局]
    E4 --> E5[返回混合数据]
    
    C7 --> F[前端渲染]
    D7 --> F
    E5 --> F
    
    F --> G[用户交互处理]
    G --> G1[节点点击]
    G --> G2[关系展开]
    G --> G3[时间筛选]
    G --> G4[快速跳转]
    
    G1 --> H{交互类型}
    G2 --> H
    G3 --> H
    G4 --> H
    
    H -->|展开详情| I[查询节点详情]
    I --> I1[获取完整信息]
    I1 --> I2[加载关联内容]
    I2 --> I3[渲染详情面板]
    
    H -->|时间跳转| J[定位到指定时间点]
    J --> J1[加载附近内容]
    J1 --> J2[高亮显示]
    
    H -->|关系探索| K[展开关系图]
    K --> K1[查询关系路径]
    K1 --> K2[可视化关系]
    
    I3 --> End([完成])
    J2 --> End
    K2 --> End
    
    style C2 fill:#bbf,stroke:#333,stroke-width:2px
    style D2 fill:#bbf,stroke:#333,stroke-width:2px
    style E1 fill:#bbf,stroke:#333,stroke-width:2px
    style K1 fill:#bbf,stroke:#333,stroke-width:2px
```

## 时间轴展示详细设计

```mermaid
flowchart LR
    subgraph 时间轴数据流
        A[用户设定时间范围] --> B[Neo4j时间查询]
        B --> C[按时间聚合数据]
        C --> D[构建时间轴层级]
        D --> D1[年层级]
        D --> D2[月层级]
        D --> D3[日层级]
        D --> D4[时间点层级]
        
        D1 --> E[关联数据查询]
        D2 --> E
        D3 --> E
        D4 --> E
        
        E --> F[关系线计算]
        F --> G[时间轴渲染数据]
    end
    
    subgraph 可视化特征
        H[节点大小] --> H1[重要性权重]
        I[节点颜色] --> I1[分类/类型]
        J[连接线] --> J1[关系类型]
        K[动画效果] --> K1[创建时间]
    end
    
    G --> L[前端渲染]
    H1 --> L
    I1 --> L
    J1 --> L
    K1 --> L
```

## 事件中心展示详细设计

```mermaid
flowchart TD
    Start([加载事件中心]) --> A[获取用户事件]
    A --> B[事件分类处理]
    
    B --> B1[项目事件]
    B --> B2[长期任务]
    B --> B3[重要事件]
    B --> B4[性格特征]
    
    B1 --> C[计算事件指标]
    B2 --> C
    B3 --> C
    B4 --> C
    
    C --> C1[进展百分比]
    C --> C2[关联内容数量]
    C --> C3[时间跨度]
    C --> C4[影响范围]
    
    C1 --> D[构建事件卡片]
    C2 --> D
    C3 --> D
    C4 --> D
    
    D --> E[查询事件子项]
    E --> F[查询相关速记]
    F --> G[计算关系强度]
    
    G --> H[生成事件树]
    H --> H1[主事件节点]
    H --> H2[子事件节点]
    H --> H3[关联内容节点]
    
    H1 --> I[渲染事件中心]
    H2 --> I
    H3 --> I
    
    I --> J[用户交互]
    J --> J1[展开/折叠]
    J --> J2[查看详情]
    J --> J3[添加子项]
    
    J1 --> End([完成])
    J2 --> End
    J3 --> End
    
    style C fill:#f9f,stroke:#333,stroke-width:2px
    style G fill:#bbf,stroke:#333,stroke-width:2px
    style H fill:#bbf,stroke:#333,stroke-width:2px
```

## 数据查询实现

### 时间轴查询

```python
async def get_timeline_data(
    user_id: int,
    start_date: str,
    end_date: str,
    granularity: str = "day"
) -> dict:
    """
    获取时间轴数据
    
    参数：
    - user_id: 用户ID
    - start_date: 开始日期
    - end_date: 结束日期
    - granularity: 粒度（year, month, day）
    """
    
    # Neo4j查询
    cypher = f"""
    MATCH (u:User {{id: $userId}})-[:CREATED]->(n)
    WHERE (n:Note OR n:Event OR n:Activity)
      AND n.created_at >= date($startDate)
      AND n.created_at <= date($endDate)
      
    WITH n, 
         CASE granularity
           WHEN 'year' THEN n.created_at.year
           WHEN 'month' THEN n.created_at.year * 100 + n.created_at.month
           ELSE n.created_at.year * 10000 + n.created_at.month * 100 + n.created_at.day
         END as time_key
    
    OPTIONAL MATCH (n)-[r]->(related)
    
    RETURN n,
           time_key,
           collect(DISTINCT {{
               id: related.id,
               type: labels(related)[0],
               title: related.title,
               relation_type: type(r),
               weight: r.weight
           }}) as relations
    ORDER BY time_key DESC, n.created_at DESC
    """
    
    results = neo4j_client.run(cypher, {
        'userId': user_id,
        'startDate': start_date,
        'endDate': end_date,
        'granularity': granularity
    }).data()
    
    # 按时间键分组
    timeline = {}
    for item in results:
        key = item['time_key']
        if key not in timeline:
            timeline[key] = {
                'time_key': key,
                'items': []
            }
        
        timeline[key]['items'].append({
            'id': item['n']['id'],
            'type': item['n'].labels[0],
            'title': item['n']['title'],
            'content': item['n'].get('content'),
            'created_at': str(item['n']['created_at']),
            'relations': item['relations']
        })
    
    return {
        'timeline': sorted(timeline.values(), key=lambda x: x['time_key'], reverse=True),
        'summary': calculate_summary(results)
    }

def calculate_summary(results: list) -> dict:
    """计算统计数据"""
    return {
        'total_items': len(results),
        'notes_count': len([r for r in results if 'Note' in r['n'].labels]),
        'events_count': len([r for r in results if 'Event' in r['n'].labels]),
        'total_relations': sum(len(r['relations']) for r in results)
    }
```

### 事件中心查询

```python
async def get_event_center(user_id: int) -> dict:
    """获取事件中心数据"""
    
    # 查询所有事件
    events_query = """
    MATCH (u:User {id: $userId})-[:CREATED]->(e:Event)
    WITH e,
         CASE e.event_type
           WHEN 'project' THEN 1
           WHEN 'long_term_task' THEN 2
           WHEN 'important_event' THEN 3
           ELSE 4
         END as priority
    
    ORDER BY priority, e.created_at DESC
    RETURN e, priority
    """
    
    events = neo4j_client.run(events_query, {'userId': user_id}).data()
    
    # 构建事件树
    event_tree = []
    for event_data in events:
        event = event_data['e']
        event_id = event['id']
        
        # 查询子事件
        sub_events_query = """
        MATCH (e:Event {id: $eventId})<-[:PARENT_OF]-(sub:Event)
        RETURN sub
        """
        sub_events = neo4j_client.run(sub_events_query, {'eventId': event_id}).data()
        
        # 查询相关速记
        related_notes_query = """
        MATCH (e:Event {id: $eventId})-[:RELATED_TO|:MENTIONS]->(n:Note)
        WITH n, r
        ORDER BY r.weight DESC
        RETURN n, {type: type(r), weight: r.weight} as relation
        LIMIT 20
        """
        related_notes = neo4j_client.run(related_notes_query, {'eventId': event_id}).data()
        
        # 计算进展
        progress = calculate_event_progress(event_id)
        
        event_tree.append({
            'event': {
                'id': event['id'],
                'title': event['title'],
                'type': event['event_type'],
                'status': event['status'],
                'priority': event['priority'],
                'start_date': str(event.get('start_date')),
                'end_date': str(event.get('end_date')),
                'created_at': str(event['created_at'])
            },
            'progress': progress,
            'sub_events': [sub['sub'] for sub in sub_events],
            'related_notes': [
                {
                    'note': note['n'],
                    'relation': note['relation']
                }
                for note in related_notes
            ],
            'statistics': {
                'sub_events_count': len(sub_events),
                'notes_count': len(related_notes),
                'total_relations': len(sub_events) + len(related_notes)
            }
        })
    
    return {
        'events': event_tree,
        'summary': {
            'total_events': len(event_tree),
            'completed': len([e for e in event_tree if e['event']['status'] == 'completed']),
            'in_progress': len([e for e in event_tree if e['event']['status'] == 'in_progress'])
        }
    }

def calculate_event_progress(event_id: int) -> dict:
    """计算事件进展"""
    progress_query = """
    MATCH (e:Event {id: $eventId})
    OPTIONAL MATCH (e)<-[:PARENT_OF]-(sub:Event)
    WITH e, count(sub) as total,
         sum(CASE WHEN sub.status = 'completed' THEN 1 ELSE 0 END) as completed
    
    RETURN total, completed,
           CASE total 
             WHEN 0 THEN 0
             ELSE round(completed * 100.0 / total, 1)
           END as progress_percent
    """
    
    result = neo4j_client.run(progress_query, {'eventId': event_id}).single()
    
    return {
        'total': result['total'],
        'completed': result['completed'],
        'progress_percent': result['progress_percent']
    }
```

## 混合展示查询

```python
async def get_mixed_view(
    user_id: int,
    start_date: str,
    end_date: str,
    min_importance: float = 0.5
) -> dict:
    """获取混合视图数据（时间轴 + 事件中心）"""
    
    # 查询关键节点（重要性阈值以上）
    key_nodes_query = """
    MATCH (u:User {id: $userId})-[:CREATED]->(n)
    WHERE (n:Note OR n:Event)
      AND n.created_at >= date($startDate)
      AND n.created_at <= date($endDate)
    
    // 计算重要性
    WITH n,
         CASE 
           WHEN n:Event THEN n.priority * 0.8 + size((n)<-[:RELATED_TO]-()) * 0.2
           WHEN n:Note THEN size((n)-[:TAGGED_WITH]->()) * 0.3 + size((n)-[:RELATED_TO]->()) * 0.7
           ELSE 0
         END as importance
    
    WHERE importance >= $minImportance
    
    // 查询关系
    OPTIONAL MATCH (n)-[r]->(related)
    
    RETURN n,
           importance,
           collect(DISTINCT {{
               id: related.id,
               type: labels(related)[0],
               title: related.title,
               relation: type(r),
               weight: r.weight
           }}) as relations
    ORDER BY n.created_at DESC
    """
    
    key_nodes = neo4j_client.run(key_nodes_query, {
        'userId': user_id,
        'startDate': start_date,
        'endDate': end_date,
        'minImportance': min_importance
    }).data()
    
    # 构建混合数据结构
    mixed_data = {
        'timeline': [],
        'key_events': [],
        'high_value_notes': []
    }
    
    for item in key_nodes:
        node = item['n']
        importance = item['important']
        
        if 'Event' in node.labels:
            # 添加到关键事件
            mixed_data['key_events'].append({
                'event': node,
                'importance': importance,
                'relations': item['relations']
            })
        
        # 添加到时间轴
        mixed_data['timeline'].append({
            'item': node,
            'type': node.labels[0],
            'importance': importance,
            'timestamp': str(node['created_at']),
            'relations': item['relations']
        })
        
        if importance > 0.8 and 'Note' in node.labels:
            mixed_data['high_value_notes'].append({
                'note': node,
                'importance': importance,
                'relations': item['relations']
            })
    
    return mixed_data
```

## 前端渲染数据格式

```typescript
// 时间轴节点接口
interface TimelineNode {
  id: number;
  type: 'Note' | 'Event' | 'Activity';
  title: string;
  content?: string;
  created_at: string;
  importance: number;
  relations: Relation[];
  visualization: {
    size: number;      // 节点大小
    color: string;     // 节点颜色
    position: { x: number, y: number };
  };
}

// 事件中心接口
interface EventCenter {
  events: EventItem[];
  summary: {
    total_events: number;
    completed: number;
    in_progress: number;
  };
}

interface EventItem {
  event: {
    id: number;
    title: string;
    type: 'project' | 'long_term_task' | 'important_event';
    status: 'pending' | 'in_progress' | 'completed';
    start_date?: string;
    end_date?: string;
  };
  progress: {
    total: number;
    completed: number;
    progress_percent: number;
  };
  sub_events: Event[];
  related_notes: Note[];
  statistics: {
    sub_events_count: number;
    notes_count: number;
    total_relations: number;
  };
}

// 混合视图接口
interface MixedView {
  timeline: TimelineNode[];
  key_events: EventItem[];
  high_value_notes: Note[];
  layout: {
    mode: 'timeline' | 'tree' | 'graph';
    config: any;
  };
}
```

## 关系可视化配置

```javascript
// 可视化配置
const vizConfig = {
  // 事件类型颜色
  eventColors: {
    project: '#FF6B6B',
    long_term_task: '#4ECDC4',
    important_event: '#45B7D1',
    personality: '#96CEB4'
  },
  
  // 关系类型样式
  relationStyles: {
    RELATED_TO: { color: '#666', dash: [], width: 2 },
    DEPENDS_ON: { color: '#FF6B6B', dash: [5, 5], width: 1 },
    TRIGGERED_BY: { color: '#4ECDC4', dash: [], width: 3 },
    TAGGED_WITH: { color: '#45B7D1', dash: [], width: 1 }
  },
  
  // 重要性映射
  importanceToSize: {
    min: 10,
    max: 50,
    threshold: 0.5
  },
  
  // 布局算法
  layout: {
    algorithm: 'force',
    options: {
      linkDistance: 100,
      charge: -300,
      gravity: 0.1
    }
  }
};
```
