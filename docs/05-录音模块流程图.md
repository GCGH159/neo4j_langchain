# 录音模块详细流程

```mermaid
flowchart TD
    Start([用户开始录音]) --> A[初始化录音设备]
    A --> B[开始音频流采集]
    
    B --> C{录音状态}
    C -->|录制中| D[实时音频数据]
    D --> E[音频缓冲区]
    E --> F[音频可视化显示]
    F --> C
    
    C -->|暂停| G[暂停音频采集]
    G --> H[保存暂停点]
    H --> I{用户操作}
    I -->|继续| B
    I -->|取消| J[删除音频数据]
    J --> End([结束])
    
    C -->|停止| K[结束音频采集]
    K --> L[合并音频片段]
    
    L --> M[音频格式转换]
    M --> M1[转换为MP3/WAV]
    M1 --> N[上传到对象存储]
    
    N --> O[获取音频URL]
    O --> P[调用语音识别服务]
    
    P --> P1[STT语音转文字]
    P1 --> P2[获取转录文本]
    P2 --> P3[文本分段和标点]
    
    P3 --> Q{识别质量检查}
    Q -->|质量差| R[标记为需要人工处理]
    Q -->|质量好| S[继续处理]
    
    R --> T[创建待处理任务]
    T --> U[通知用户手动编辑]
    
    S --> V[创建速记记录]
    V --> V1[MySQL保存基础信息]
    V1 --> V2[Neo4j创建Note节点]
    V2 --> V3[关联音频URL]
    
    V3 --> W[调用速记关联Agent]
    W --> X[执行关联分析]
    X --> Y[生成智能标签]
    Y --> Z[完成关联]
    
    Z --> AA[更新速记状态]
    AA --> AB[清除Redis缓存]
    AB --> End2([完成])
    
    U --> End2
    
    style P fill:#f9f,stroke:#333,stroke-width:2px
    style P1 fill:#f9f,stroke:#333,stroke-width:2px
    style V2 fill:#bbf,stroke:#333,stroke-width:2px
    style W fill:#f9f,stroke:#333,stroke-width:2px
```

## 录音处理时序图

```mermaid
sequenceDiagram
    participant U as 用户
    participant Client as 前端
    participant API as 后端API
    participant OSS as 对象存储
    participant STT as 语音识别服务
    participant MySQL as 数据库
    participant Neo4j as 图库
    participant Agent as LangChain Agent
    participant Redis as 缓存
    
    U->>Client: 开始录音
    Client->>Client: 采集音频流
    Client->>Client: 实时显示波形
    
    U->>Client: 停止录音
    Client->>Client: 音频处理与压缩
    
    Client->>API: 上传音频
    API->>OSS: 存储音频文件
    OSS-->>API: 返回音频URL
    
    API->>API: 创建临时速记记录
    API->>MySQL: 插入notes表
    MySQL-->>API: 返回note_id
    
    API->>STT: 发起语音识别
    STT->>STT: 音频转文字
    STT-->>API: 返回转录文本
    
    API->>API: 文本处理（分段、标点）
    
    API->>Neo4j: 创建Note节点
    Neo4j-->>API: 节点创建成功
    
    API->>Agent: 启动关联分析
    Agent->>Neo4j: 查询用户关系图谱
    Neo4j-->>Agent: 返回关系数据
    
    Agent->>Agent: 分析内容
    Agent->>Agent: 生成标签
    Agent->>Agent: 推荐关联
    
    Agent->>Neo4j: 创建关系边
    Neo4j-->>Agent: 创建成功
    
    Agent->>MySQL: 更新速记信息
    MySQL-->>Agent: 更新成功
    
    Agent->>Redis: 清除缓存
    Redis-->>Agent: 缓存清除
    
    Agent-->>API: 处理完成
    API-->>Client: 返回完整速记
    Client-->>U: 展示速记内容
```

## 数据模型

### MySQL表结构

```sql
-- 录音任务表
CREATE TABLE audio_recordings (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    note_id BIGINT NOT NULL,
    audio_url VARCHAR(500) NOT NULL,
    audio_duration INT DEFAULT 0, -- 秒
    audio_size BIGINT DEFAULT 0, -- 字节
    audio_format VARCHAR(20) DEFAULT 'mp3',
    sample_rate INT DEFAULT 16000,
    channels INT DEFAULT 1,
    status ENUM('uploading', 'processing', 'completed', 'failed') DEFAULT 'uploading',
    transcript_status ENUM('pending', 'processing', 'completed', 'manual_review') DEFAULT 'pending',
    transcript_text TEXT,
    transcript_confidence DECIMAL(3,2) DEFAULT 0.00,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_note_id (note_id),
    INDEX idx_status (status),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (note_id) REFERENCES notes(id) ON DELETE CASCADE
);

-- 转录分段表（用于长音频分段）
CREATE TABLE transcript_segments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    recording_id BIGINT NOT NULL,
    segment_index INT NOT NULL,
    start_time DECIMAL(10,2) NOT NULL, -- 秒
    end_time DECIMAL(10,2) NOT NULL,
    text TEXT NOT NULL,
    confidence DECIMAL(3,2),
    speaker VARCHAR(50), -- 说话人识别
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_recording_id (recording_id),
    FOREIGN KEY (recording_id) REFERENCES audio_recordings(id) ON DELETE CASCADE
);
```

### 音频处理配置

```yaml
audio_processing:
  chunk_duration: 30  # 分块时长（秒）
  sample_rate: 16000  # 采样率
  channels: 1         # 声道数
  bitrate: 128k       # 比特率
  format: mp3         # 输出格式
  
  # 支持的格式
  supported_formats:
    - mp3
    - wav
    - m4a
    - aac
  
  # STT服务配置
  stt_service: openai_whisper
  stt_model: base
  stt_language: zh-CN
  enable_punctuation: true
  enable_segmentation: true
```

## 语音识别Agent

```python
from langchain.agents import AgentExecutor

class TranscriptionAgent:
    """转录与处理Agent"""
    
    def __init__(self, stt_client, llm):
        self.stt_client = stt_client
        self.llm = llm
    
    def process_audio(self, audio_file_path: str) -> dict:
        """处理音频文件"""
        # 1. 音频预处理
        processed_audio = self._preprocess_audio(audio_file_path)
        
        # 2. 语音转文字
        transcription = self._transcribe(processed_audio)
        
        # 3. 文本后处理
        processed_text = self._post_process_text(transcription)
        
        # 4. 质量评估
        quality_score = self._assess_quality(processed_text)
        
        return {
            'text': processed_text,
            'confidence': transcription['confidence'],
            'quality_score': quality_score,
            'needs_manual_review': quality_score < 0.7,
            'segments': transcription['segments']
        }
    
    def _transcribe(self, audio_data: bytes) -> dict:
        """调用STT服务"""
        response = self.stt_client.audio.transcriptions.create(
            model="whisper-1",
            file=audio_data,
            language="zh",
            response_format="verbose_json"
        )
        
        return {
            'text': response.text,
            'segments': response.segments,
            'confidence': self._calculate_confidence(response.segments)
        }
    
    def _post_process_text(self, transcription: str) -> str:
        """文本后处理：分段、标点"""
        prompt = f"""
        对以下转录文本进行优化：
        1. 添加适当的标点符号
        2. 合理分段
        3. 修正明显的识别错误
        
        原文：{transcription}
        
        输出优化后的文本：
        """
        return self.llm.predict(prompt)
    
    def _assess_quality(self, text: str) -> float:
        """评估转录质量"""
        prompt = f"""
        评估以下语音转录的质量（0-1分）：
        文本：{text}
        
        评估维度：
        1. 语义连贯性
        2. 语法正确性
        3. 是否有明显错误
        
        只返回数字评分。
        """
        score = self.llm.predict(prompt)
        return float(score)
```

## 对象存储集成

```python
import oss2

class AudioStorage:
    """音频存储管理"""
    
    def __init__(self, config):
        self.auth = oss2.Auth(config['access_key'], config['secret_key'])
        self.bucket = oss2.Bucket(self.auth, config['endpoint'], config['bucket'])
    
    def upload_audio(self, file_path: str, user_id: int) -> str:
        """上传音频文件"""
        # 生成唯一文件名
        filename = f"audio/{user_id}/{uuid.uuid4()}.mp3"
        
        # 上传文件
        result = self.bucket.put_object_from_file(filename, file_path)
        
        # 返回公开访问URL
        return f"{self.bucket.endpoint}/{self.bucket.bucket_name}/{filename}"
    
    def get_signed_url(self, object_key: str, expires: int = 3600) -> str:
        """生成签名URL（私有访问）"""
        return self.bucket.sign_url('GET', object_key, expires)
```
